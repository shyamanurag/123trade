# f_and_o_scalping_system/models.py
"""
Core data models for the trading system
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List
from enum import Enum

class OrderSide(Enum):
    BUY = "BUY"
    SELL = "SELL"

    class OrderType(Enum):
        MARKET = "MARKET"
        LIMIT = "LIMIT"
        SL = "SL"
        SL_M = "SL-M"
        BRACKET = "BRACKET"
        CONDITIONAL = "CONDITIONAL"
        MULTI_LEG = "MULTI_LEG"

        class OrderStatus(Enum):
            PENDING = "PENDING"
            PLACED = "PLACED"
            FILLED = "FILLED"
            PARTIALLY_FILLED = "PARTIALLY_FILLED"
            CANCELLED = "CANCELLED"
            REJECTED = "REJECTED"
            EXPIRED = "EXPIRED"

            class PositionStatus(Enum):
                OPEN = "OPEN"
                PARTIALLY_CLOSED = "PARTIALLY_CLOSED"
                CLOSED = "CLOSED"

                class OptionType(Enum):
                    CALL = "CE"
                    PUT = "PE"

                    @dataclass
                    class Signal:
                        """Trading signal generated by strategies"""

                        def to_dict(self) -> Dict:
                            return {
                                'signal_id': self.signal_id,
                                'strategy_name': self.strategy_name,
                                'symbol': self.symbol,
                                'option_type': self.option_type.value,
                                'strike': self.strike,
                                'action': self.action.value,
                                'quality_score': self.quality_score,
                                'quantity': self.quantity,
                                'entry_price': self.entry_price,
                                'stop_loss_percent': self.stop_loss_percent,
                                'target_percent': self.target_percent,
                                'time_stop': self.time_stop.isoformat() if self.time_stop else None,
                                'metadata': self.metadata,
                                'timestamp': self.timestamp.isoformat()
                            }

                    @dataclass
                    class Position:
                        """Active trading position"""

                        # P&L fields

                        # Risk fields

                        # Metadata

                        def update_pnl(self, current_price: float):
                            """Update P&L calculations"""
                            position_value = self.quantity * self.entry_price
                            current_value = self.quantity * current_price

                            # Track extremes

                            """Close the position"""

                            position_value = self.quantity * self.entry_price
                            exit_value = self.quantity * exit_price

                            def to_dict(self) -> Dict:
                                return {
                                    'position_id': self.position_id,
                                    'symbol': self.symbol,
                                    'option_type': self.option_type.value,
                                    'strike': self.strike,
                                    'quantity': self.quantity,
                                    'entry_price': self.entry_price,
                                    'entry_time': self.entry_time.isoformat(),
                                    'current_price': self.current_price,
                                    'exit_price': self.exit_price,
                                    'exit_time': self.exit_time.isoformat() if self.exit_time else None,
                                    'status': self.status.value,
                                    'strategy_name': self.strategy_name,
                                    'unrealized_pnl': self.unrealized_pnl,
                                    'realized_pnl': self.realized_pnl,
                                    'pnl_percent': self.pnl_percent,
                                    'metadata': self.metadata
                                }

                    @dataclass
                    class MarketData:
                        """Market data snapshot"""
                        symbol: str
                        timestamp: datetime
                        spot_price: float

                        # OHLC data

                        # Derived metrics

                        # Historical data references

                        def to_dict(self) -> Dict:
                            return {
                                'symbol': self.symbol,
                                'timestamp': self.timestamp.isoformat(),
                                'spot_price': self.spot_price,
                                'ltp': self.ltp,
                                'bid': self.bid,
                                'ask': self.ask,
                                'volume': self.volume,
                                'oi': self.oi,
                                'vix': self.vix,
                                'ohlc': {
                                    'open': self.open,
                                    'high': self.high,
                                    'low': self.low,
                                    'close': self.close},
                                'metrics': {
                                    'daily_atr': self.daily_atr,
                                    'hourly_volatility': self.hourly_volatility,
                                    'volume_surge': self.volume_surge
                                }
                            }

@dataclass
class Order:
    """Enhanced order representation with user-specific information"""
    order_id: str
    user_id: str
    signal_id: Optional[str]
    broker_order_id: Optional[str]
    parent_order_id: Optional[str]
    symbol: str
    option_type: OrderType
    strike: float
    quantity: int
    order_type: OrderType
    side: OrderSide
    price: Optional[float]
    execution_strategy: ExecutionStrategy
    slice_number: Optional[int]
    total_slices: Optional[int]
    state: OrderState
    status: OrderStatus
    filled_quantity: int = 0
    average_price: Optional[float] = None
    fees: float = 0.0
    slippage: float = 0.0
    market_impact: float = 0.0
    strategy_name: Optional[str] = None
    position_id: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    queued_at: Optional[datetime] = None
    sent_at: Optional[datetime] = None
    placed_at: Optional[datetime] = None
    filled_at: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class MultiLegOrder:
    """Multi-leg order representation"""
    order_id: str
    user_id: str
    legs: List[Order]
    strategy_name: str
    state: OrderState
    status: OrderStatus
    created_at: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class BracketOrder:
    """Bracket order representation"""
    order_id: str
    user_id: str
    entry_order: Order
    take_profit_order: Order
    stop_loss_order: Order
    state: OrderState
    status: OrderStatus
    created_at: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class ConditionalOrder:
    """Conditional order representation"""
    order_id: str
    user_id: str
    trigger_order: Order
    triggered_order: Order
    condition: str
    condition_value: float
    state: OrderState
    status: OrderStatus
    created_at: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

